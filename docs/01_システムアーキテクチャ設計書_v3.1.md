# システムアーキテクチャ設計書 v3.1 (Part 1/3)

**プロジェクト名**: AIフィットネスアプリ(仮称)  
**バージョン**: 3.1  
**作成日**: 2025年11月21日  
**最終更新日**: 2025年11月21日  
**対象期間**: Phase 1-2 (0-4ヶ月)

---

## 📝 v3.1での主な変更点

### 法的要件との完全な整合性

✅ **要件定義書v3.1との整合**:
- 全31機能要件、全32非機能要件に対応
- 薬機法対応の表現を完全統一
- GDPR/EDPB Guidelines準拠の実装詳細

✅ **利用規約v3.1との整合**:
- 第3.3条: 医療機器でない旨をシステム設計に反映
- 第5条: 認証システムの詳細設計
- 第6条: 課金システムの詳細設計

✅ **プライバシーポリシーv3.1との整合**:
- 第8条: セキュリティ対策の具体的実装
- 第9条: GDPR対応機能の技術的実装
- オンデバイス処理、仮名化、暗号化の詳細

✅ **技術的保護措置の詳細化**:
- TLS 1.3、AES-256の具体的な実装方法
- Firebase Security Rulesの完全な設定
- Cloud IAMのロール設計
- データフローの各段階でのセキュリティ対策

✅ **プライバシーバイデザイン**:
- GDPR第25条準拠の設計原則
- データ最小化の実装
- デフォルトでのプライバシー保護

---

## 目次

### Part 1: 概要〜アプリケーション層
1. [概要](#1-概要)
2. [システム全体構成](#2-システム全体構成)
3. [アーキテクチャ原則](#3-アーキテクチャ原則)
4. [アプリケーション層](#4-アプリケーション層)

### Part 2: バックエンド層〜データ層
5. [バックエンド層](#5-バックエンド層)
6. [データ層](#6-データ層)
7. [認証・認可](#7-認証認可)

### Part 3: セキュリティ〜運用
8. [セキュリティアーキテクチャ](#8-セキュリティアーキテクチャ)
9. [データフロー](#9-データフロー)
10. [スケーラビリティ設計](#10-スケーラビリティ設計)
11. [監視・ログ](#11-監視ログ)
12. [災害復旧](#12-災害復旧)
13. [開発・デプロイメント](#13-開発デプロイメント)

---

## 1. 概要

### 1.1 ドキュメントの目的

本ドキュメントは、AIフィットネスアプリ(仮称)のシステムアーキテクチャを定義し、以下を明確にします:

1. **システム全体構成**: 各コンポーネントの役割と関係
2. **技術スタック**: 使用する技術とその選定理由
3. **データフロー**: データの流れとセキュリティ対策
4. **スケーラビリティ**: 成長に対応する設計
5. **セキュリティ**: GDPR/EDPB Guidelines準拠の実装
6. **運用**: 監視、ログ、災害復旧

### 1.2 参照ドキュメント

| ドキュメント | バージョン | 参照箇所 |
|------------|----------|---------|
| **要件定義書** | v3.1 | 全体、特に第3章(機能要件)、第4章(非機能要件) |
| **利用規約** | v3.1 | 第3条(サービスの概要)、第5条(認証)、第6条(課金) |
| **プライバシーポリシー** | v3.1 | 第8条(セキュリティ)、第9条(ユーザー権利) |

### 1.3 対象読者

- プロジェクトマネージャー
- フロントエンドエンジニア
- バックエンドエンジニア
- QAエンジニア
- セキュリティ担当者
- インフラ担当者

### 1.4 システム概要

本システムは、スマートフォンのカメラとAI技術(MediaPipe Pose)を活用し、トレーニングフォームの確認を補助する参考情報を提供するモバイルアプリケーションです。

**重要な位置づけ**(要件定義書v3.1第1.2.3項、利用規約v3.1第3.3条):
- ✅ トレーニングフォームの確認を補助する参考情報提供ツール
- ✅ 参考情報として利用者に情報を表示するサービス
- ✅ 最終的な判断は利用者自身の責任において行うもの
- ❌ 医療機器ではありません(薬機法)
- ❌ 診断・治療・予防を目的としません

### 1.5 主要な技術的特徴

| 特徴 | 説明 | 法的根拠 |
|-----|------|---------|
| **オンデバイス処理** | カメラ映像は端末上でのみ処理 | プライバシーポリシーv3.1第8.1条 |
| **仮名化** | ユーザーIDをSHA-256でハッシュ化 | プライバシーポリシーv3.1第8.3条 |
| **エンドツーエンド暗号化** | TLS 1.3による通信暗号化 | プライバシーポリシーv3.1第8.4条 |
| **データ暗号化** | AES-256によるデータ暗号化 | プライバシーポリシーv3.1第8.4条 |
| **アクセス制御** | Firebase Security Rules + Cloud IAM | プライバシーポリシーv3.1第8.2条 |
| **GDPR準拠** | 同意管理、データ削除、エクスポート | プライバシーポリシーv3.1第9条 |

---

## 2. システム全体構成

### 2.1 システムアーキテクチャ図

```
┌─────────────────────────────────────────────────────────────────────┐
│                        クライアント層                                │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                   Flutter App (iOS/Android)                   │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐     │  │
│  │  │ UI Layer │  │ State    │  │ MediaPipe│  │ Firebase │     │  │
│  │  │ (Widgets)│  │ Mgmt     │  │ Pose     │  │ SDK      │     │  │
│  │  │          │  │ (Riverpod│  │(On-Device│  │          │     │  │
│  │  │          │  │)         │  │)         │  │          │     │  │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘     │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                    TLS 1.3 暗号化通信(HTTPS)
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        Firebase Services                            │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │Firebase  │  │Firestore │  │ Cloud    │  │ Cloud    │           │
│  │Auth      │  │ (NoSQL)  │  │ Functions│  │ Storage  │           │
│  │(認証)    │  │          │  │ (Node.js)│  │          │           │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │ FCM      │  │ Cloud    │  │ Firebase │  │ Firebase │           │
│  │(通知)    │  │ Scheduler│  │ Analytics│  │ Crashlyt.│           │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘           │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                      BigQuery Export / API Call
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                   Google Cloud Platform (GCP)                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │ BigQuery │  │ Cloud    │  │ Looker   │  │ Cloud    │           │
│  │ (DWH)    │  │ Logging  │  │ Studio   │  │Monitoring│           │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │ Cloud    │  │ Security │  │ Cloud    │  │ Cloud KMS│           │
│  │ IAM      │  │ Command  │  │ Armor    │  │(鍵管理)  │           │
│  │          │  │ Center   │  │          │  │          │           │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘           │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                              第三者サービス
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        External Services                            │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │RevenueCat│  │ App Store│  │ Google   │  │ MediaPipe│           │
│  │(課金管理)│  │ (Apple)  │  │ Play     │  │ (Google) │           │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘           │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 レイヤー構成

| レイヤー | 役割 | 主要コンポーネント | 法的要件 |
|---------|------|------------------|---------|
| **クライアント層** | ユーザーインターフェース、オンデバイス処理 | Flutter App, MediaPipe Pose | プライバシーポリシー第8.1条 |
| **Firebase層** | 認証、データベース、サーバーレス関数 | Firebase Auth, Firestore, Cloud Functions | 利用規約第5条 |
| **GCP層** | データ分析、監視、セキュリティ | BigQuery, Cloud Logging, Security Command Center | プライバシーポリシー第8.5条 |
| **外部サービス層** | 課金、配信 | RevenueCat, App Store, Google Play | 利用規約第6条 |

### 2.3 技術スタック

#### 2.3.1 フロントエンド

| カテゴリ | 技術 | バージョン | 選定理由 |
|---------|------|----------|---------|
| **フレームワーク** | Flutter | 3.x | iOS/Android同時開発、高パフォーマンス |
| **言語** | Dart | 3.x | Flutter公式言語、型安全 |
| **状態管理** | Riverpod | 2.x | 宣言的、テスト容易、パフォーマンス |
| **AI/ML** | MediaPipe Pose | Latest | オンデバイス処理、高精度骨格検出 |
| **ローカルDB** | Hive | 2.x | 高速、軽量、暗号化対応 |
| **DI** | get_it | 7.x | 依存性注入、テスト容易 |

#### 2.3.2 バックエンド

| カテゴリ | 技術 | 選定理由 | 法的要件 |
|---------|------|---------|---------|
| **BaaS** | Firebase | スケーラビリティ、マネージド | - |
| **認証** | Firebase Authentication | OAuth対応、JWT | 利用規約第5条 |
| **データベース** | Firestore | リアルタイム同期、NoSQL | プライバシーポリシー第8.2条 |
| **サーバーレス** | Cloud Functions | Node.js 18、サーバーレス | - |
| **DWH** | BigQuery | 大規模データ分析 | プライバシーポリシー第5条 |
| **課金** | RevenueCat | サブスクリプション管理 | 利用規約第6条 |

#### 2.3.3 インフラ・運用

| カテゴリ | 技術 | 選定理由 | 法的要件 |
|---------|------|---------|---------|
| **クラウド** | Google Cloud Platform | Firebase統合、GDPR準拠 | - |
| **監視** | Cloud Monitoring | 統合監視 | - |
| **ログ** | Cloud Logging | 集中ログ管理 | プライバシーポリシー第8.5条 |
| **セキュリティ** | Security Command Center | 脆弱性検知 | プライバシーポリシー第8.5条 |
| **CI/CD** | GitHub Actions | 自動ビルド・デプロイ | - |
| **バージョン管理** | Git / GitHub | ソースコード管理 | - |

#### 2.3.4 セキュリティ

| カテゴリ | 技術 | 詳細 | 法的要件 |
|---------|------|------|---------|
| **通信暗号化** | TLS 1.3 | すべての通信を暗号化 | プライバシーポリシー第8.4条 |
| **データ暗号化** | AES-256 | 保存データを暗号化 | プライバシーポリシー第8.4条 |
| **鍵管理** | Cloud KMS | 暗号鍵の管理 | プライバシーポリシー第8.4条 |
| **アクセス制御** | Cloud IAM | ロールベースアクセス制御 | プライバシーポリシー第8.2条 |
| **Firestore Rules** | Firebase Security Rules | データベースアクセス制御 | プライバシーポリシー第8.2条 |
| **仮名化** | SHA-256 | ユーザーIDのハッシュ化 | プライバシーポリシー第8.3条 |

---

## 3. アーキテクチャ原則

### 3.1 設計原則

#### 3.1.1 SOLID原則

| 原則 | 説明 | 適用例 |
|-----|------|--------|
| **単一責任の原則** | 1クラス1責任 | 各Repositoryは1つのデータソースのみ担当 |
| **開放閉鎖の原則** | 拡張に開き、修正に閉じる | インターフェース定義によるDI |
| **リスコフの置換原則** | 派生クラスは基底クラスと置換可能 | Abstract Repositoryの実装 |
| **インターフェース分離の原則** | クライアントは使わないメソッドに依存しない | 機能ごとのインターフェース分離 |
| **依存性逆転の原則** | 抽象に依存、具象に依存しない | DI(get_it)による疎結合 |

#### 3.1.2 クリーンアーキテクチャ

```
┌─────────────────────────────────────────────────────────┐
│                    Presentation Layer                   │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐       │
│  │ Widgets│  │ Pages  │  │ State  │  │ View   │       │
│  │        │  │        │  │Provider│  │ Models │       │
│  └────────┘  └────────┘  └────────┘  └────────┘       │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                     Domain Layer                        │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐       │
│  │Entities│  │Use Cases│ │Repository│ │Failures│       │
│  │        │  │        │  │Interfaces│ │        │       │
│  └────────┘  └────────┘  └────────┘  └────────┘       │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                      Data Layer                         │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐       │
│  │Data    │  │Data    │  │Remote  │  │ Local  │       │
│  │Sources │  │Models  │  │ Data   │  │ Data   │       │
│  │        │  │        │  │ Source │  │ Source │       │
│  └────────┘  └────────┘  └────────┘  └────────┘       │
└─────────────────────────────────────────────────────────┘
```

**依存関係のルール**:
- 外側から内側への依存のみ許可
- 内側の層は外側の層を知らない
- Domain層はフレームワークに依存しない

#### 3.1.3 プライバシーバイデザイン

**GDPR第25条準拠**(プライバシーポリシーv3.1第8条):

| 原則 | 実装 | 法的根拠 |
|-----|------|---------|
| **データ最小化** | 必要最小限のデータのみ収集 | GDPR第5条1項(c) |
| **デフォルトでプライバシー保護** | カメラ映像は端末上でのみ処理 | プライバシーポリシー第8.1条 |
| **エンドツーエンド保護** | TLS 1.3 + AES-256 | プライバシーポリシー第8.4条 |
| **透明性** | データ処理の明示的な説明 | プライバシーポリシー全体 |
| **ユーザーコントロール** | 同意管理、データ削除、エクスポート | プライバシーポリシー第9条 |
| **セキュリティ** | 暗号化、アクセス制御 | プライバシーポリシー第8条 |
| **説明責任** | ROPA、監査ログ | GDPR第30条 |

### 3.2 非機能要件との対応

**要件定義書v3.1第4章(非機能要件)との対応**:

| 非機能要件ID | 要件 | アーキテクチャ対応 |
|------------|------|------------------|
| **NFR-001** | アプリ起動時間3秒以内 | 遅延読み込み、画像最適化 |
| **NFR-002** | MediaPipe 30fps以上 | GPUアクセラレーション、liteモデル |
| **NFR-003** | APIレスポンス200ms以内 | Firestoreインデックス、CDN |
| **NFR-005** | アップタイム99.5%以上 | Firebaseマネージドサービス |
| **NFR-009** | 通信暗号化TLS 1.3 | Firebase SDK自動対応 |
| **NFR-010** | データ暗号化AES-256 | Cloud KMS、Firestore自動暗号化 |
| **NFR-011** | 認証JWT, OAuth 2.0 | Firebase Authentication |
| **NFR-012** | アクセス制御Cloud IAM | Cloud IAM + Firestore Security Rules |
| **NFR-015** | オンデバイス処理 | MediaPipe端末実行 |
| **NFR-016** | 仮名化SHA-256 | Cloud Functions実装 |
| **NFR-019** | 同意管理 | Firestore + UI実装 |
| **NFR-020** | データ侵害通知72時間以内 | Cloud Logging + アラート |

### 3.3 スケーラビリティ戦略

#### 3.3.1 水平スケーリング

| コンポーネント | スケーリング方法 | 上限 |
|-------------|---------------|------|
| **Firestore** | 自動シャーディング | 実質無制限 |
| **Cloud Functions** | 自動スケール | 1,000同時実行(デフォルト) |
| **BigQuery** | 自動スケール | ペタバイト級 |
| **Firebase Authentication** | 自動スケール | 実質無制限 |

#### 3.3.2 パフォーマンス最適化

| レイヤー | 最適化手法 |
|---------|----------|
| **フロントエンド** | 遅延読み込み、画像圧縮、コード分割 |
| **ネットワーク** | CDN、圧縮、HTTP/2 |
| **バックエンド** | インデックス、クエリ最適化、キャッシュ |
| **データベース** | 複合インデックス、パーティショニング |

---

## 4. アプリケーション層

### 4.1 Flutter App アーキテクチャ

#### 4.1.1 レイヤー構成

```
lib/
├── main.dart                    # エントリーポイント
├── app/                         # アプリケーション設定
│   ├── app.dart                 # MaterialApp
│   ├── router.dart              # ルーティング(go_router)
│   ├── theme.dart               # テーマ設定
│   └── providers.dart           # グローバルProvider
├── core/                        # 共通機能
│   ├── constants/               # 定数
│   ├── errors/                  # エラー定義
│   ├── utils/                   # ユーティリティ
│   └── di/                      # 依存性注入(get_it)
├── features/                    # 機能モジュール
│   ├── auth/                    # 認証(FR-001〜003)
│   │   ├── presentation/        # UI
│   │   ├── domain/              # ビジネスロジック
│   │   └── data/                # データアクセス
│   ├── training/                # トレーニング(FR-004〜008)
│   │   ├── presentation/
│   │   ├── domain/
│   │   └── data/
│   ├── record/                  # 記録(FR-009〜012)
│   ├── search/                  # 検索(FR-013〜014)
│   ├── settings/                # 設定(FR-015〜017)
│   ├── notification/            # 通知(FR-018〜019)
│   ├── subscription/            # 課金(FR-020〜023)
│   ├── privacy/                 # GDPR対応(FR-024〜027)
│   └── data_collection/         # データ収集(FR-028〜029)
└── shared/                      # 共有ウィジェット・モデル
    ├── widgets/
    ├── models/
    └── services/
```

#### 4.1.2 状態管理(Riverpod)

**選定理由**:
- 宣言的で理解しやすい
- テストが容易
- パフォーマンスが高い
- null-safetyサポート
- Providerの依存関係管理が容易

**基本構成**:

```dart
// Provider定義例
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return AuthRepositoryImpl(
    firebaseAuth: FirebaseAuth.instance,
    firestore: FirebaseFirestore.instance,
  );
});

final authStateProvider = StreamProvider<User?>((ref) {
  final repository = ref.watch(authRepositoryProvider);
  return repository.authStateChanges();
});

// UI層での利用
class HomePage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authStateProvider);
    return authState.when(
      data: (user) => user != null ? MainScreen() : LoginScreen(),
      loading: () => LoadingScreen(),
      error: (error, stack) => ErrorScreen(error: error),
    );
  }
}
```

#### 4.1.3 MediaPipe統合

**オンデバイス処理**(プライバシーポリシーv3.1第8.1条):

```dart
class PoseDetectionService {
  final PoseDetector _poseDetector;
  
  PoseDetectionService() 
    : _poseDetector = PoseDetector(
        options: PoseDetectorOptions(
          mode: PoseDetectionMode.stream,
          model: PoseModel.lite, // 軽量モデル(NFR-002対応)
        ),
      );
  
  /// カメラ映像から骨格を検出
  /// 重要: 映像は端末上でのみ処理、サーバーに送信しない
  Future<List<Pose>> detectPose(InputImage inputImage) async {
    try {
      final poses = await _poseDetector.processImage(inputImage);
      return poses;
    } catch (e) {
      // エラーハンドリング
      throw PoseDetectionException(e.toString());
    }
  }
  
  /// 骨格座標のみを返す(カメラ映像は含まない)
  List<PoseLandmark> extractLandmarks(Pose pose) {
    return pose.landmarks.values.toList();
  }
  
  @override
  void dispose() {
    _poseDetector.close();
  }
}
```

**重要**: カメラ映像はメモリ上でのみ処理し、保存・送信しません(プライバシーポリシー第8.1条)。

#### 4.1.4 ローカルデータ管理

**Hive使用**(暗号化対応):

```dart
class LocalStorageService {
  late Box<UserProfile> _userBox;
  late Box<TrainingSession> _sessionBox;
  
  /// 初期化(暗号化キー設定)
  Future<void> init() async {
    // 暗号化キーの生成・取得
    final encryptionKey = await _getEncryptionKey();
    
    // 暗号化Boxの初期化
    _userBox = await Hive.openBox<UserProfile>(
      'user_profile',
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
    
    _sessionBox = await Hive.openBox<TrainingSession>(
      'training_sessions',
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
  }
  
  /// ユーザープロフィールの保存
  Future<void> saveUserProfile(UserProfile profile) async {
    await _userBox.put('current_user', profile);
  }
  
  /// トレーニングセッションの保存(オフライン対応)
  Future<void> saveSession(TrainingSession session) async {
    await _sessionBox.add(session);
  }
  
  /// データ削除(FR-025: 忘れられる権利)
  Future<void> deleteAllData() async {
    await _userBox.clear();
    await _sessionBox.clear();
  }
}
```

**セキュリティ**:
- すべてのローカルデータをAES暗号化
- 暗号化キーはFlutter Secure Storageで管理
- アプリアンインストール時に自動削除

#### 4.1.5 ナビゲーション(go_router)

```dart
final routerProvider = Provider<GoRouter>((ref) {
  final authState = ref.watch(authStateProvider);
  
  return GoRouter(
    initialLocation: '/splash',
    redirect: (context, state) {
      // 認証状態に基づくリダイレクト
      final isLoggedIn = authState.value != null;
      final isLoginRoute = state.location == '/login';
      
      if (!isLoggedIn && !isLoginRoute) {
        return '/login';
      }
      if (isLoggedIn && isLoginRoute) {
        return '/home';
      }
      return null;
    },
    routes: [
      GoRoute(
        path: '/splash',
        builder: (context, state) => SplashScreen(),
      ),
      GoRoute(
        path: '/login',
        builder: (context, state) => LoginScreen(),
      ),
      GoRoute(
        path: '/home',
        builder: (context, state) => HomeScreen(),
        routes: [
          GoRoute(
            path: 'training/:exerciseId',
            builder: (context, state) => TrainingScreen(
              exerciseId: state.params['exerciseId']!,
            ),
          ),
          GoRoute(
            path: 'record',
            builder: (context, state) => RecordScreen(),
          ),
          GoRoute(
            path: 'settings',
            builder: (context, state) => SettingsScreen(),
            routes: [
              GoRoute(
                path: 'privacy',
                builder: (context, state) => PrivacySettingsScreen(),
              ),
            ],
          ),
        ],
      ),
    ],
  );
});
```

#### 4.1.6 エラーハンドリング

```dart
// カスタムエラー定義
abstract class Failure {
  final String message;
  const Failure(this.message);
}

class NetworkFailure extends Failure {
  const NetworkFailure([String? message]) 
    : super(message ?? 'ネットワークエラーが発生しました');
}

class ServerFailure extends Failure {
  const ServerFailure([String? message]) 
    : super(message ?? 'サーバーエラーが発生しました');
}

class CacheFailure extends Failure {
  const CacheFailure([String? message]) 
    : super(message ?? 'データの保存に失敗しました');
}

class AuthFailure extends Failure {
  const AuthFailure([String? message]) 
    : super(message ?? '認証に失敗しました');
}

class PoseDetectionFailure extends Failure {
  const PoseDetectionFailure([String? message]) 
    : super(message ?? 'フォーム確認補助の処理に失敗しました');
}

// Either型でエラーハンドリング
typedef Result<T> = Either<Failure, T>;

// 使用例
Future<Result<User>> login(String email, String password) async {
  try {
    final user = await _authRepository.signIn(email, password);
    return Right(user);
  } on FirebaseAuthException catch (e) {
    return Left(AuthFailure(e.message));
  } catch (e) {
    return Left(ServerFailure());
  }
}
```

#### 4.1.7 国際化(i18n)

**Phase 1-2では日本語のみ**(要件定義書v3.1第5.3条):

```dart
// l10n/app_ja.arb
{
  "appTitle": "AIフィットネスアプリ",
  "loginTitle": "ログイン",
  "referenceScore": "参考スコア",
  "referenceInfo": "参考:",
  "notMedicalDevice": "本サービスは医療機器ではありません",
  "disclaimer": "最終的な判断は利用者自身の責任において行ってください"
}
```

**表現の注意**(利用規約v3.1第1.4条):
- ✅ 「参考スコア」「参考情報」「確認補助」
- ❌ 「判定」「正しいフォーム」「改善アドバイス」

### 4.2 UI/UX設計

#### 4.2.1 デザインシステム

**カラーパレット**:

```dart
class AppColors {
  // プライマリカラー
  static const primary = Color(0xFF2196F3);
  static const primaryDark = Color(0xFF1976D2);
  static const primaryLight = Color(0xFFBBDEFB);
  
  // アクセントカラー
  static const accent = Color(0xFFFF5722);
  
  // セマンティックカラー
  static const success = Color(0xFF4CAF50);
  static const warning = Color(0xFFFFC107);
  static const error = Color(0xFFF44336);
  static const info = Color(0xFF2196F3);
  
  // ニュートラル
  static const background = Color(0xFFFAFAFA);
  static const surface = Color(0xFFFFFFFF);
  static const textPrimary = Color(0xFF212121);
  static const textSecondary = Color(0xFF757575);
}
```

**タイポグラフィ**:

```dart
class AppTextStyles {
  static const h1 = TextStyle(
    fontSize: 32,
    fontWeight: FontWeight.bold,
    color: AppColors.textPrimary,
  );
  
  static const h2 = TextStyle(
    fontSize: 24,
    fontWeight: FontWeight.bold,
    color: AppColors.textPrimary,
  );
  
  static const body1 = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );
  
  static const caption = TextStyle(
    fontSize: 12,
    fontWeight: FontWeight.normal,
    color: AppColors.textSecondary,
  );
}
```

#### 4.2.2 共通ウィジェット

```dart
// 参考スコア表示ウィジェット
class ReferenceScoreWidget extends StatelessWidget {
  final double score; // 0-100
  
  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          children: [
            Text(
              '参考スコア', // 薬機法対応(利用規約第1.4条)
              style: AppTextStyles.caption,
            ),
            Text(
              '${score.toInt()}',
              style: AppTextStyles.h1,
            ),
            Text(
              '※あくまで参考情報です', // 免責表示(利用規約第3.3条)
              style: AppTextStyles.caption,
            ),
          ],
        ),
      ),
    );
  }
}

// 同意確認ダイアログ(GDPR対応)
class ConsentDialog extends StatelessWidget {
  final String title;
  final String content;
  final VoidCallback onAccept;
  
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(title),
      content: SingleChildScrollView(
        child: Text(content),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text('同意しない'),
        ),
        ElevatedButton(
          onPressed: () {
            onAccept();
            Navigator.pop(context);
          },
          child: Text('同意する'),
        ),
      ],
    );
  }
}
```

---

**Part 1 完了**

Part 1には以下が含まれています:
- 概要
- システム全体構成
- アーキテクチャ原則
- アプリケーション層(Flutter App)

Part 2には以下を含めます:
- バックエンド層(Firebase, Cloud Functions)
- データ層(Firestore, BigQuery)
- 認証・認可

Part 3には以下を含めます:
- セキュリティアーキテクチャ
- データフロー
- スケーラビリティ設計
- 監視・ログ
- 災害復旧
- 開発・デプロイメント

---

**Document Version**: v3.1 (Part 1/3)  
**Last Updated**: 2025年11月21日  
**Author**: Project Team  
**Status**: Draft
# システムアーキテクチャ設計書 v3.1 (Part 2/3)

**プロジェクト名**: AIフィットネスアプリ(仮称)  
**バージョン**: 3.1  
**作成日**: 2025年11月21日  
**最終更新日**: 2025年11月21日

---

## 5. バックエンド層

### 5.1 Firebase Services

#### 5.1.1 Firebase Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Firebase Services                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐         ┌──────────────┐                 │
│  │  Firebase    │────────│  Firestore   │                 │
│  │ Authentication        │              │                 │
│  │              │         │  (NoSQL DB)  │                 │
│  │ - JWT        │         │              │                 │
│  │ - OAuth 2.0  │         │ - Collections│                 │
│  └──────────────┘         │ - Documents  │                 │
│         │                 │ - Security   │                 │
│         │                 │   Rules      │                 │
│         ▼                 └──────────────┘                 │
│  ┌──────────────┐                │                         │
│  │              │                ▼                         │
│  │ Cloud        │         ┌──────────────┐                 │
│  │ Functions    │────────│  BigQuery    │                 │
│  │              │         │              │                 │
│  │ - Node.js 18 │         │  (Export)    │                 │
│  │ - TypeScript │         └──────────────┘                 │
│  └──────────────┘                                          │
│         │                                                   │
│         ▼                                                   │
│  ┌──────────────┐         ┌──────────────┐                 │
│  │ Cloud        │         │ Cloud        │                 │
│  │ Storage      │         │ Scheduler    │                 │
│  │              │         │              │                 │
│  │ - Files      │         │ - Cron Jobs  │                 │
│  └──────────────┘         └──────────────┘                 │
│         │                        │                         │
│         ▼                        ▼                         │
│  ┌──────────────┐         ┌──────────────┐                 │
│  │ FCM          │         │ Firebase     │                 │
│  │ (Push Notify)│         │ Analytics    │                 │
│  └──────────────┘         └──────────────┘                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 5.1.2 Cloud Functions

**プロジェクト構成**:

```
functions/
├── src/
│   ├── index.ts                # エントリーポイント
│   ├── config/                 # 設定
│   │   ├── firebase.ts         # Firebase設定
│   │   └── constants.ts        # 定数
│   ├── triggers/               # トリガー関数
│   │   ├── auth/               # 認証トリガー
│   │   │   ├── onUserCreate.ts # ユーザー作成時(FR-001)
│   │   │   └── onUserDelete.ts # ユーザー削除時(FR-025)
│   │   ├── firestore/          # Firestoreトリガー
│   │   │   ├── onSessionCreate.ts # セッション作成時(FR-028)
│   │   │   └── onSessionUpdate.ts # セッション更新時
│   │   └── scheduled/          # スケジュール実行
│   │       ├── dailyBackup.ts  # 日次バックアップ
│   │       └── cleanupOldData.ts # 古いデータ削除
│   ├── api/                    # HTTP API
│   │   ├── subscription/       # 課金API(FR-020〜023)
│   │   ├── analytics/          # 分析API
│   │   └── export/             # データエクスポート(FR-027)
│   ├── services/               # ビジネスロジック
│   │   ├── bigquery.service.ts # BigQuery連携
│   │   ├── pseudonymize.service.ts # 仮名化(NFR-016)
│   │   └── notification.service.ts # 通知送信
│   └── utils/                  # ユーティリティ
│       ├── validation.ts       # バリデーション
│       └── error.ts            # エラーハンドリング
├── package.json
├── tsconfig.json
└── .eslintrc.js
```

**主要な関数**:

##### onUserCreate (認証トリガー)

```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';

/**
 * ユーザー作成時の処理
 * - Firestoreにユーザードキュメント作成
 * - デフォルト設定の初期化
 * - 法的根拠: 利用規約v3.1第5条、GDPR第6条1項(b)契約の履行
 */
export const onUserCreate = functions.auth.user().onCreate(async (user) => {
  const firestore = admin.firestore();
  
  try {
    // ユーザードキュメント作成
    await firestore.collection('users').doc(user.uid).set({
      email: user.email,
      displayName: user.displayName,
      photoURL: user.photoURL,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      // デフォルト設定
      settings: {
        notifications: {
          training: true,
          news: true,
        },
        privacy: {
          dataCollection: true, // FR-028, FR-029
          analytics: false, // オプトイン
        },
      },
      // 同意記録(NFR-019)
      consents: {
        termsOfService: {
          version: 'v3.1',
          acceptedAt: admin.firestore.FieldValue.serverTimestamp(),
        },
        privacyPolicy: {
          version: 'v3.1',
          acceptedAt: admin.firestore.FieldValue.serverTimestamp(),
        },
      },
    });
    
    // ウェルカムメール送信(オプション)
    // await sendWelcomeEmail(user.email);
    
    functions.logger.info(`User created: ${user.uid}`);
  } catch (error) {
    functions.logger.error('Error creating user document:', error);
    throw new functions.https.HttpsError('internal', 'ユーザー作成に失敗しました');
  }
});
```

##### onUserDelete (認証トリガー)

```typescript
/**
 * ユーザー削除時の処理(忘れられる権利)
 * - Firestoreからユーザーデータ削除
 * - BigQueryからユーザーデータ削除
 * - Cloud Storageからファイル削除
 * - 法的根拠: プライバシーポリシーv3.1第9.6条、GDPR第17条
 */
export const onUserDelete = functions.auth.user().onDelete(async (user) => {
  const firestore = admin.firestore();
  const storage = admin.storage();
  const bigquery = new BigQuery();
  
  try {
    // 1. Firestoreからユーザーデータ削除
    const batch = firestore.batch();
    
    // ユーザードキュメント
    batch.delete(firestore.collection('users').doc(user.uid));
    
    // トレーニングセッション
    const sessions = await firestore
      .collection('sessions')
      .where('userId', '==', user.uid)
      .get();
    sessions.docs.forEach(doc => batch.delete(doc.ref));
    
    await batch.commit();
    
    // 2. Cloud Storageからファイル削除
    const bucket = storage.bucket();
    await bucket.deleteFiles({
      prefix: `users/${user.uid}/`,
    });
    
    // 3. BigQueryからデータ削除(仮名化されたID)
    const pseudonymizedId = pseudonymizeUserId(user.uid);
    await bigquery
      .dataset('fitness_data')
      .table('sessions')
      .query({
        query: `DELETE FROM \`fitness_data.sessions\` WHERE user_id = @userId`,
        params: { userId: pseudonymizedId },
      });
    
    await bigquery
      .dataset('fitness_data')
      .table('pose_landmarks')
      .query({
        query: `DELETE FROM \`fitness_data.pose_landmarks\` WHERE user_id = @userId`,
        params: { userId: pseudonymizedId },
      });
    
    functions.logger.info(`User deleted: ${user.uid}`);
  } catch (error) {
    functions.logger.error('Error deleting user data:', error);
    throw new functions.https.HttpsError('internal', 'ユーザーデータの削除に失敗しました');
  }
});
```

##### onSessionCreate (Firestoreトリガー)

```typescript
/**
 * トレーニングセッション作成時の処理
 * - BigQueryへのデータエクスポート
 * - 仮名化処理
 * - 法的根拠: プライバシーポリシーv3.1第5条、GDPR第6条1項(f)正当な利益
 */
export const onSessionCreate = functions.firestore
  .document('sessions/{sessionId}')
  .onCreate(async (snap, context) => {
    const session = snap.data();
    const sessionId = context.params.sessionId;
    
    try {
      // ユーザーIDを仮名化(NFR-016)
      const pseudonymizedUserId = pseudonymizeUserId(session.userId);
      
      // BigQueryへエクスポート
      const bigquery = new BigQuery();
      const dataset = bigquery.dataset('fitness_data');
      const table = dataset.table('sessions');
      
      await table.insert([{
        session_id: sessionId,
        user_id: pseudonymizedUserId, // 仮名化されたID
        exercise_id: session.exerciseId,
        rep_count: session.repCount,
        set_count: session.setCount,
        duration: session.duration,
        average_score: session.averageScore,
        created_at: session.createdAt,
        metadata: JSON.stringify(session.metadata || {}),
      }]);
      
      // 骨格座標データも同様にエクスポート(FR-028)
      if (session.landmarks && session.landmarks.length > 0) {
        const landmarksTable = dataset.table('pose_landmarks');
        const landmarksData = session.landmarks.map((landmark: any, index: number) => ({
          session_id: sessionId,
          user_id: pseudonymizedUserId,
          frame_number: index,
          landmarks: JSON.stringify(landmark),
          created_at: session.createdAt,
        }));
        
        await landmarksTable.insert(landmarksData);
      }
      
      functions.logger.info(`Session exported to BigQuery: ${sessionId}`);
    } catch (error) {
      functions.logger.error('Error exporting session to BigQuery:', error);
      // エラーが発生してもユーザーの体験を妨げないため、ログのみ
    }
  });
```

##### exportUserData (HTTP API)

```typescript
/**
 * ユーザーデータのエクスポート(データポータビリティ)
 * - Firestore、BigQueryからデータ取得
 * - JSON/CSV形式で出力
 * - Cloud Storageに一時保存
 * - ダウンロードリンク生成(有効期限7日間)
 * - 法的根拠: プライバシーポリシーv3.1第9.5条、GDPR第20条
 */
export const exportUserData = functions.https.onCall(async (data, context) => {
  // 認証チェック
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', '認証が必要です');
  }
  
  const userId = context.auth.uid;
  const format = data.format || 'json'; // 'json' or 'csv'
  
  try {
    const firestore = admin.firestore();
    const bigquery = new BigQuery();
    const storage = admin.storage();
    
    // 1. Firestoreからデータ取得
    const userDoc = await firestore.collection('users').doc(userId).get();
    const sessionsSnap = await firestore
      .collection('sessions')
      .where('userId', '==', userId)
      .get();
    
    // 2. BigQueryからデータ取得
    const pseudonymizedId = pseudonymizeUserId(userId);
    const [sessionsRows] = await bigquery.query({
      query: `
        SELECT * FROM \`fitness_data.sessions\`
        WHERE user_id = @userId
        ORDER BY created_at DESC
      `,
      params: { userId: pseudonymizedId },
    });
    
    const [landmarksRows] = await bigquery.query({
      query: `
        SELECT * FROM \`fitness_data.pose_landmarks\`
        WHERE user_id = @userId
        ORDER BY created_at DESC
      `,
      params: { userId: pseudonymizedId },
    });
    
    // 3. データを整形
    const exportData = {
      user: userDoc.data(),
      sessions: sessionsSnap.docs.map(doc => doc.data()),
      bigquery_sessions: sessionsRows,
      bigquery_landmarks: landmarksRows,
      exported_at: new Date().toISOString(),
      format_version: 'v1.0',
    };
    
    // 4. ファイル生成
    const filename = `user_data_${userId}_${Date.now()}.${format}`;
    const file = storage.bucket().file(`exports/${userId}/${filename}`);
    
    if (format === 'json') {
      await file.save(JSON.stringify(exportData, null, 2), {
        contentType: 'application/json',
      });
    } else if (format === 'csv') {
      // CSV変換ロジック(省略)
      const csvData = convertToCSV(exportData);
      await file.save(csvData, {
        contentType: 'text/csv',
      });
    }
    
    // 5. 署名付きURL生成(有効期限7日間)
    const [signedUrl] = await file.getSignedUrl({
      action: 'read',
      expires: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7日後
    });
    
    // 6. エクスポート履歴を記録
    await firestore.collection('export_logs').add({
      userId,
      filename,
      format,
      exportedAt: admin.firestore.FieldValue.serverTimestamp(),
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    });
    
    functions.logger.info(`Data exported for user: ${userId}`);
    
    return {
      downloadUrl: signedUrl,
      filename,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
    };
  } catch (error) {
    functions.logger.error('Error exporting user data:', error);
    throw new functions.https.HttpsError('internal', 'データのエクスポートに失敗しました');
  }
});
```

##### pseudonymizeUserId (ユーティリティ)

```typescript
import * as crypto from 'crypto';

/**
 * ユーザーIDの仮名化
 * - SHA-256ハッシュ化
 * - ソルト使用(環境変数)
 * - 法的根拠: プライバシーポリシーv3.1第8.3条、GDPR第4条5項
 */
export function pseudonymizeUserId(userId: string): string {
  const salt = process.env.PSEUDONYMIZATION_SALT || 'default_salt';
  return crypto
    .createHash('sha256')
    .update(userId + salt)
    .digest('hex');
}
```

#### 5.1.3 Cloud Scheduler (Cron Jobs)

```typescript
/**
 * 日次バックアップ(毎日午前3時)
 */
export const dailyBackup = functions.pubsub
  .schedule('0 3 * * *')
  .timeZone('Asia/Tokyo')
  .onRun(async (context) => {
    // Firestoreバックアップ
    const firestore = admin.firestore();
    // バックアップロジック(省略)
    
    functions.logger.info('Daily backup completed');
  });

/**
 * 古いエクスポートファイルの削除(毎日午前4時)
 */
export const cleanupExpiredExports = functions.pubsub
  .schedule('0 4 * * *')
  .timeZone('Asia/Tokyo')
  .onRun(async (context) => {
    const storage = admin.storage();
    const firestore = admin.firestore();
    
    // 有効期限切れのエクスポートファイルを削除
    const expiredExports = await firestore
      .collection('export_logs')
      .where('expiresAt', '<', new Date())
      .get();
    
    const batch = firestore.batch();
    for (const doc of expiredExports.docs) {
      const data = doc.data();
      
      // Cloud Storageからファイル削除
      await storage
        .bucket()
        .file(`exports/${data.userId}/${data.filename}`)
        .delete()
        .catch(err => functions.logger.error('File deletion error:', err));
      
      // ログ削除
      batch.delete(doc.ref);
    }
    
    await batch.commit();
    functions.logger.info(`Cleaned up ${expiredExports.size} expired exports`);
  });
```

---

## 6. データ層

### 6.1 Firestore設計

#### 6.1.1 コレクション構造

```
firestore/
├── users/                          # ユーザー情報
│   └── {userId}/
│       ├── profile                 # プロフィール
│       ├── settings                # 設定
│       └── consents                # 同意記録
├── exercises/                      # 種目マスターデータ
│   └── {exerciseId}/
│       ├── name                    # 種目名
│       ├── category                # カテゴリ
│       └── difficulty              # 難易度
├── sessions/                       # トレーニングセッション
│   └── {sessionId}/
│       ├── userId                  # ユーザーID
│       ├── exerciseId              # 種目ID
│       ├── repCount                # レップ数
│       └── createdAt               # 作成日時
├── notifications/                  # 通知
│   └── {notificationId}/
│       ├── userId                  # ユーザーID
│       ├── type                    # 通知タイプ
│       └── read                    # 既読フラグ
├── subscriptions/                  # サブスクリプション
│   └── {userId}/
│       ├── status                  # ステータス
│       ├── planId                  # プランID
│       └── expiresAt               # 有効期限
└── export_logs/                    # エクスポート履歴
    └── {exportId}/
        ├── userId                  # ユーザーID
        ├── filename                # ファイル名
        └── expiresAt               # 有効期限
```

#### 6.1.2 データモデル

##### users コレクション

```typescript
interface User {
  // 基本情報
  email: string;
  displayName: string | null;
  photoURL: string | null;
  dateOfBirth: Timestamp; // 年齢確認用(暗号化)
  
  // タイムスタンプ
  createdAt: Timestamp;
  updatedAt: Timestamp;
  
  // 設定
  settings: {
    notifications: {
      training: boolean;      // トレーニングリマインダー
      news: boolean;          // お知らせ
    };
    privacy: {
      dataCollection: boolean;  // データ収集(FR-028, FR-029)
      analytics: boolean;       // 分析データ利用
      marketing: boolean;       // マーケティング利用
    };
  };
  
  // 同意記録(NFR-019)
  consents: {
    termsOfService: {
      version: string;          // 'v3.1'
      acceptedAt: Timestamp;
    };
    privacyPolicy: {
      version: string;          // 'v3.1'
      acceptedAt: Timestamp;
    };
    dataCollection?: {
      version: string;
      acceptedAt: Timestamp;
      revokedAt?: Timestamp;
    };
  };
  
  // プロフィール
  profile?: {
    height?: number;            // cm
    weight?: number;            // kg
    goal?: string;              // トレーニング目標
  };
}
```

##### exercises コレクション

```typescript
interface Exercise {
  // 基本情報
  id: string;
  name: string;                 // 例: 'スクワット'
  nameEn?: string;              // 例: 'Squat'(Phase 3以降)
  
  // 分類
  category: 'bodyweight' | 'dumbbell' | 'barbell';
  targetMuscles: string[];      // ['下半身', '大腿四頭筋']
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  
  // 説明
  description: string;
  instructions: string[];       // 手順
  
  // MediaPipe設定
  mediapipeConfig: {
    keyPoints: string[];        // 監視する骨格ポイント
    thresholds: {
      [key: string]: number;    // 角度の閾値
    };
  };
  
  // メタデータ
  thumbnailURL?: string;
  videoURL?: string;
  createdAt: Timestamp;
  updatedAt: Timestamp;
}
```

##### sessions コレクション

```typescript
interface TrainingSession {
  // 基本情報
  id: string;
  userId: string;               // ユーザーID
  exerciseId: string;           // 種目ID
  
  // トレーニングデータ
  repCount: number;             // レップ数
  setCount: number;             // セット数
  duration: number;             // 秒
  weight?: number;              // kg(ダンベル等)
  
  // 参考スコア(利用規約第1.2条)
  averageScore: number;         // 平均参考スコア(0-100)
  scores: number[];             // 各レップの参考スコア
  
  // 骨格座標データ(FR-028)
  // 注意: 大量データのためサブコレクションまたはCloud Storageに保存
  landmarksRef?: string;        // Cloud Storage参照
  
  // メタデータ
  metadata: {
    appVersion: string;
    deviceInfo: {
      os: 'iOS' | 'Android';
      version: string;
      model: string;
    };
  };
  
  // タイムスタンプ
  createdAt: Timestamp;
  updatedAt: Timestamp;
}
```

##### subscriptions コレクション

```typescript
interface Subscription {
  // 基本情報
  userId: string;
  
  // プラン情報(利用規約第6条)
  planId: 'free' | 'premium';
  status: 'active' | 'canceled' | 'expired' | 'trial';
  
  // 課金情報
  revenueCatId: string;         // RevenueCat顧客ID
  platform: 'ios' | 'android';
  originalTransactionId: string;
  
  // 期間
  currentPeriodStart: Timestamp;
  currentPeriodEnd: Timestamp;
  trialEnd?: Timestamp;         // 無料トライアル終了日
  
  // タイムスタンプ
  createdAt: Timestamp;
  updatedAt: Timestamp;
  canceledAt?: Timestamp;
}
```

#### 6.1.3 Security Rules

**完全なSecurity Rules**(プライバシーポリシーv3.1第8.2条):

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ヘルパー関数
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/admins/$(request.auth.uid)).data.role == 'admin';
    }
    
    // usersコレクション: 自分のデータのみアクセス可能
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && 
                      // createdAtは変更不可
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny(['createdAt']);
      allow delete: if isOwner(userId);
    }
    
    // exercisesコレクション: 全ユーザーが読み取り可能、管理者のみ書き込み可能
    match /exercises/{exerciseId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // sessionsコレクション: 自分のセッションのみアクセス可能
    match /sessions/{sessionId} {
      allow read: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid &&
                      // 必須フィールドのチェック
                      request.resource.data.keys().hasAll(['userId', 'exerciseId', 'repCount', 'createdAt']);
      allow update: if isOwner(resource.data.userId);
      allow delete: if isOwner(resource.data.userId);
    }
    
    // notificationsコレクション: 自分の通知のみアクセス可能
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
      allow update: if isOwner(resource.data.userId) && 
                      // readフラグのみ更新可能
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'updatedAt']);
      allow create, delete: if false; // Cloud Functionsのみ作成・削除可能
    }
    
    // subscriptionsコレクション: 自分のサブスクリプションのみ読み取り可能
    match /subscriptions/{userId} {
      allow read: if isOwner(userId);
      allow write: if false; // Cloud Functionsのみ書き込み可能
    }
    
    // export_logsコレクション: 自分のログのみ読み取り可能
    match /export_logs/{exportId} {
      allow read: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
      allow write: if false; // Cloud Functionsのみ書き込み可能
    }
    
    // デフォルト: すべて拒否
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
```

#### 6.1.4 インデックス設計

**複合インデックス**(パフォーマンス最適化):

```javascript
// firestore.indexes.json
{
  "indexes": [
    // sessionsコレクション: ユーザーごとの最新セッション取得
    {
      "collectionGroup": "sessions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    // sessionsコレクション: ユーザーと種目でフィルタ
    {
      "collectionGroup": "sessions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "exerciseId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    // exercisesコレクション: カテゴリと難易度でフィルタ
    {
      "collectionGroup": "exercises",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "category", "order": "ASCENDING" },
        { "fieldPath": "difficulty", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    // notificationsコレクション: 未読通知取得
    {
      "collectionGroup": "notifications",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "read", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    }
  ]
}
```

### 6.2 BigQuery設計

#### 6.2.1 データセット構成

```
fitness_data (Dataset)
├── sessions (Table)                # トレーニングセッション
├── pose_landmarks (Table)          # 骨格座標データ
├── user_analytics (Table)          # ユーザー分析
└── app_events (Table)              # アプリイベント
```

#### 6.2.2 テーブルスキーマ

##### sessions テーブル

```sql
CREATE TABLE `fitness_data.sessions` (
  -- 識別子
  session_id STRING NOT NULL,
  user_id STRING NOT NULL,              -- 仮名化されたユーザーID(SHA-256)
  exercise_id STRING NOT NULL,
  
  -- トレーニングデータ
  rep_count INT64 NOT NULL,
  set_count INT64 NOT NULL,
  duration INT64 NOT NULL,              -- 秒
  weight FLOAT64,                       -- kg
  
  -- 参考スコア
  average_score FLOAT64,                -- 0-100
  
  -- メタデータ
  metadata JSON,                        -- デバイス情報等
  
  -- タイムスタンプ
  created_at TIMESTAMP NOT NULL,
  
  -- パーティショニング・クラスタリング用
  _PARTITIONTIME TIMESTAMP
)
PARTITION BY DATE(created_at)
CLUSTER BY user_id, exercise_id
OPTIONS(
  description="トレーニングセッションデータ",
  require_partition_filter=true
);
```

##### pose_landmarks テーブル

```sql
CREATE TABLE `fitness_data.pose_landmarks` (
  -- 識別子
  session_id STRING NOT NULL,
  user_id STRING NOT NULL,              -- 仮名化されたユーザーID
  frame_number INT64 NOT NULL,
  
  -- 骨格座標データ(33ランドマーク)
  landmarks ARRAY<STRUCT<
    x FLOAT64,
    y FLOAT64,
    z FLOAT64,
    visibility FLOAT64
  >> NOT NULL,
  
  -- メタデータ
  metadata JSON,
  
  -- タイムスタンプ
  created_at TIMESTAMP NOT NULL,
  
  -- パーティショニング・クラスタリング用
  _PARTITIONTIME TIMESTAMP
)
PARTITION BY DATE(created_at)
CLUSTER BY session_id
OPTIONS(
  description="MediaPipe骨格座標データ(ML学習用)",
  require_partition_filter=true
);
```

#### 6.2.3 データ保存期限

**GDPR第5条1項(e)準拠**:

```sql
-- sessions テーブル: 作成から2年後に自動削除
ALTER TABLE `fitness_data.sessions`
SET OPTIONS (
  partition_expiration_days=730
);

-- pose_landmarks テーブル: 作成から2年後に自動削除
ALTER TABLE `fitness_data.pose_landmarks`
SET OPTIONS (
  partition_expiration_days=730
);
```

**法的根拠**: プライバシーポリシーv3.1第6条(情報の保存期間)

---

## 7. 認証・認可

### 7.1 Firebase Authentication

#### 7.1.1 認証フロー

**メール/パスワード認証**(FR-001):

```
┌──────┐                                          ┌──────────────┐
│Client│                                          │Firebase Auth │
└──┬───┘                                          └──────┬───────┘
   │                                                      │
   │ 1. signUpWithEmailAndPassword(email, password)      │
   │─────────────────────────────────────────────────────>│
   │                                                      │
   │                 2. ユーザー作成                      │
   │                 3. JWT発行                           │
   │<─────────────────────────────────────────────────────│
   │                                                      │
   │ 4. onAuthStateChanged                                │
   │<─────────────────────────────────────────────────────│
   │                                                      │
   │ 5. Cloud Functions Trigger: onUserCreate             │
   │                 (Firestoreにユーザードキュメント作成)│
   │                                                      │
```

**OAuth認証**(FR-002):

```
┌──────┐     ┌──────────────┐     ┌──────────────┐
│Client│     │Firebase Auth │     │ Google/Apple │
└──┬───┘     └──────┬───────┘     └──────┬───────┘
   │                │                     │
   │ 1. signInWithProvider()              │
   │───────────────>│                     │
   │                │ 2. OAuth Flow       │
   │                │────────────────────>│
   │                │<────────────────────│
   │                │ 3. ID Token         │
   │                │                     │
   │<───────────────│                     │
   │ 4. JWT         │                     │
```

#### 7.1.2 JWT構造

```json
{
  "header": {
    "alg": "RS256",
    "typ": "JWT"
  },
  "payload": {
    "iss": "https://securetoken.google.com/[PROJECT_ID]",
    "aud": "[PROJECT_ID]",
    "auth_time": 1700000000,
    "user_id": "abc123...",
    "sub": "abc123...",
    "iat": 1700000000,
    "exp": 1700003600,
    "email": "user@example.com",
    "email_verified": true,
    "firebase": {
      "identities": {
        "email": ["user@example.com"]
      },
      "sign_in_provider": "password"
    }
  }
}
```

**有効期限**: 1時間(NFR-011)

#### 7.1.3 セッション管理

```typescript
class AuthService {
  private auth = getAuth();
  
  /**
   * 認証状態の監視
   */
  onAuthStateChanged(callback: (user: User | null) => void): Unsubscribe {
    return this.auth.onAuthStateChanged(callback);
  }
  
  /**
   * トークンのリフレッシュ
   */
  async refreshToken(): Promise<string> {
    const user = this.auth.currentUser;
    if (!user) throw new Error('Not authenticated');
    
    return await user.getIdToken(true);
  }
  
  /**
   * ログアウト
   */
  async signOut(): Promise<void> {
    await this.auth.signOut();
  }
}
```

### 7.2 認可(Authorization)

#### 7.2.1 ロールベースアクセス制御(RBAC)

```typescript
// カスタムクレーム
interface CustomClaims {
  role?: 'user' | 'admin';
  subscription?: 'free' | 'premium';
}

// 管理者権限の付与(Cloud Functions)
export const setAdminRole = functions.https.onCall(async (data, context) => {
  // 既存の管理者のみ実行可能
  if (!context.auth || !context.auth.token.role === 'admin') {
    throw new functions.https.HttpsError('permission-denied', '権限がありません');
  }
  
  const targetUserId = data.userId;
  await admin.auth().setCustomUserClaims(targetUserId, { role: 'admin' });
  
  return { success: true };
});
```

#### 7.2.2 サブスクリプションによるアクセス制御

```dart
class SubscriptionGuard {
  final SubscriptionRepository _repository;
  
  /// プレミアム機能のアクセスチェック
  Future<bool> canAccessPremiumFeature() async {
    final subscription = await _repository.getCurrentSubscription();
    
    return subscription != null && 
           subscription.status == 'active' &&
           subscription.planId == 'premium';
  }
  
  /// 無料プランの制限チェック(1日3回まで)
  Future<bool> canAccessFreeFeature() async {
    final today = DateTime.now();
    final sessionsToday = await _repository.getSessionsCount(
      startDate: DateTime(today.year, today.month, today.day),
    );
    
    return sessionsToday < 3; // 無料プランは1日3回まで
  }
}
```

---

**Part 2 完了**

Part 2には以下が含まれています:
- バックエンド層(Firebase Services、Cloud Functions)
- データ層(Firestore設計、BigQuery設計)
- 認証・認可(Firebase Authentication、RBAC)

Part 3には以下を含めます:
- セキュリティアーキテクチャ
- データフロー
- スケーラビリティ設計
- 監視・ログ
- 災害復旧
- 開発・デプロイメント

---

**Document Version**: v3.1 (Part 2/3)  
**Last Updated**: 2025年11月21日  
**Author**: Project Team  
**Status**: Draft
# システムアーキテクチャ設計書 v3.1 (Part 3/3)

**プロジェクト名**: AIフィットネスアプリ(仮称)  
**バージョン**: 3.1  
**作成日**: 2025年11月21日  
**最終更新日**: 2025年11月21日

---

## 8. セキュリティアーキテクチャ

### 8.1 多層防御戦略

**Defense in Depth**(プライバシーポリシーv3.1第8条):

```
┌─────────────────────────────────────────────────────────┐
│ Layer 7: ユーザー教育・意識向上                         │
├─────────────────────────────────────────────────────────┤
│ Layer 6: 監視・ログ・インシデント対応                   │
├────────────────────────────────────────────────────────┤
│ Layer 5: アプリケーション層                             │
│  - 入力検証、エラーハンドリング、セッション管理        │
├─────────────────────────────────────────────────────────┤
│ Layer 4: 認証・認可                                     │
│  - Firebase Authentication (JWT, OAuth 2.0)            │
│  - Firestore Security Rules、Cloud IAM                │
├─────────────────────────────────────────────────────────┤
│ Layer 3: データ保護                                     │
│  - 暗号化(TLS 1.3, AES-256)、仮名化                    │
├─────────────────────────────────────────────────────────┤
│ Layer 2: ネットワーク                                   │
│  - Cloud Armor (DDoS対策、WAF)                         │
├─────────────────────────────────────────────────────────┤
│ Layer 1: インフラ                                       │
│  - Google Cloud Platform (物理的セキュリティ)          │
└─────────────────────────────────────────────────────────┘
```

### 8.2 通信セキュリティ

#### 8.2.1 TLS 1.3実装

**法的根拠**: プライバシーポリシーv3.1第8.4条

**設定**:

```yaml
# Firebase Hosting設定(firebase.json)
{
  "hosting": {
    "public": "public",
    "headers": [
      {
        "source": "**",
        "headers": [
          {
            "key": "Strict-Transport-Security",
            "value": "max-age=31536000; includeSubDomains; preload"
          },
          {
            "key": "X-Content-Type-Options",
            "value": "nosniff"
          },
          {
            "key": "X-Frame-Options",
            "value": "DENY"
          },
          {
            "key": "X-XSS-Protection",
            "value": "1; mode=block"
          },
          {
            "key": "Content-Security-Policy",
            "value": "default-src 'self'; script-src 'self' 'unsafe-inline' https://www.gstatic.com; style-src 'self' 'unsafe-inline';"
          }
        ]
      }
    ]
  }
}
```

**検証**:
- SSL Labs で A+ 評価を取得
- TLS 1.2以下を無効化
- Perfect Forward Secrecy (PFS) 有効化

#### 8.2.2 Certificate Pinning

```dart
class SecurityConfig {
  /// Certificate Pinning設定
  static List<String> getCertificatePins() {
    return [
      // Firebase/GCP証明書のSHA-256ハッシュ
      'sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',
      // バックアップ証明書
      'sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=',
    ];
  }
}

// HTTP Client設定
HttpClient createSecureClient() {
  final client = HttpClient();
  client.badCertificateCallback = (cert, host, port) {
    // Certificate Pinningチェック
    return SecurityConfig.getCertificatePins().contains(
      sha256.convert(cert.der).toString(),
    );
  };
  return client;
}
```

### 8.3 データ暗号化

#### 8.3.1 暗号化レイヤー

**法的根拠**: プライバシーポリシーv3.1第8.4条

| レイヤー | 暗号化方式 | 実装 |
|---------|----------|------|
| **転送時** | TLS 1.3 | Firebase SDK自動 |
| **保存時** | AES-256 | Firestore/BigQuery自動、Hive手動 |
| **アプリ内** | AES-256 | Flutter Secure Storage |
| **バックアップ** | AES-256 | Cloud KMS |

#### 8.3.2 鍵管理(Cloud KMS)

```typescript
import { KeyManagementServiceClient } from '@google-cloud/kms';

class KMSService {
  private client = new KeyManagementServiceClient();
  private keyName = 'projects/[PROJECT]/locations/asia-northeast1/keyRings/fitness-app/cryptoKeys/data-encryption';
  
  /**
   * データの暗号化
   */
  async encrypt(plaintext: string): Promise<string> {
    const [result] = await this.client.encrypt({
      name: this.keyName,
      plaintext: Buffer.from(plaintext),
    });
    
    return result.ciphertext.toString('base64');
  }
  
  /**
   * データの復号化
   */
  async decrypt(ciphertext: string): Promise<string> {
    const [result] = await this.client.decrypt({
      name: this.keyName,
      ciphertext: Buffer.from(ciphertext, 'base64'),
    });
    
    return result.plaintext.toString();
  }
}
```

**鍵のローテーション**: 90日ごと(自動)

### 8.4 脆弱性対策

#### 8.4.1 OWASP Top 10対策

| 脆弱性 | 対策 | 実装箇所 |
|-------|------|---------|
| **A01: Broken Access Control** | Firestore Security Rules、Cloud IAM | データ層 |
| **A02: Cryptographic Failures** | TLS 1.3、AES-256、Cloud KMS | 全層 |
| **A03: Injection** | 入力検証、パラメータ化クエリ | アプリ層、バックエンド層 |
| **A04: Insecure Design** | セキュアデザイン原則、脅威モデリング | 設計 |
| **A05: Security Misconfiguration** | Security Command Center、定期監査 | インフラ層 |
| **A06: Vulnerable Components** | 依存関係の定期更新、Snyk | 開発プロセス |
| **A07: Authentication Failures** | Firebase Authentication、MFA | 認証層 |
| **A08: Software and Data Integrity** | コード署名、CI/CD検証 | デプロイメント |
| **A09: Security Logging Failures** | Cloud Logging、アラート | 監視層 |
| **A10: Server-Side Request Forgery** | ホワイトリスト、検証 | バックエンド層 |

#### 8.4.2 入力検証

```dart
class ValidationService {
  /// メールアドレス検証
  static String? validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'メールアドレスを入力してください';
    }
    
    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    if (!emailRegex.hasMatch(value)) {
      return '有効なメールアドレスを入力してください';
    }
    
    return null;
  }
  
  /// パスワード検証
  static String? validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'パスワードを入力してください';
    }
    
    if (value.length < 8) {
      return 'パスワードは8文字以上で入力してください';
    }
    
    // 英数字記号を含む
    final hasUppercase = RegExp(r'[A-Z]').hasMatch(value);
    final hasLowercase = RegExp(r'[a-z]').hasMatch(value);
    final hasDigit = RegExp(r'[0-9]').hasMatch(value);
    final hasSpecialChar = RegExp(r'[!@#$%^&*(),.?":{}|<>]').hasMatch(value);
    
    if (!hasUppercase || !hasLowercase || !hasDigit || !hasSpecialChar) {
      return 'パスワードは大文字、小文字、数字、記号を含む必要があります';
    }
    
    return null;
  }
  
  /// XSS対策: HTMLエスケープ
  static String escapeHtml(String text) {
    return text
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#x27;');
  }
}
```

### 8.5 プライバシー保護実装

#### 8.5.1 オンデバイス処理

**法的根拠**: プライバシーポリシーv3.1第8.1条

```dart
class PrivacyProtectedPoseDetection {
  final PoseDetector _detector;
  
  /// カメラ映像からフォーム確認補助
  /// 重要: 映像は端末上でのみ処理、サーバーに送信しない
  Future<PoseAnalysisResult> analyzePose(CameraImage image) async {
    // 1. MediaPipeで骨格検出(端末上)
    final inputImage = InputImage.fromBytes(
      bytes: image.planes[0].bytes,
      inputImageData: InputImageData(
        size: Size(image.width.toDouble(), image.height.toDouble()),
        imageRotation: InputImageRotation.rotation0deg,
        inputImageFormat: InputImageFormat.nv21,
        planeData: image.planes.map((plane) => 
          InputImagePlaneMetadata(
            bytesPerRow: plane.bytesPerRow,
            height: plane.height,
            width: plane.width,
          ),
        ).toList(),
      ),
    );
    
    final poses = await _detector.processImage(inputImage);
    
    // 2. 骨格座標のみを抽出(カメラ映像は含まない)
    final landmarks = poses.isNotEmpty 
        ? poses.first.landmarks.values.toList()
        : <PoseLandmark>[];
    
    // 3. 参考スコア算出(端末上)
    final score = _calculateReferenceScore(landmarks);
    
    // 4. 画像データは即座に破棄(メモリから削除)
    // image.dispose(); // 自動的にガベージコレクション
    
    return PoseAnalysisResult(
      landmarks: landmarks,  // 骨格座標のみ
      referenceScore: score,
    );
  }
  
  double _calculateReferenceScore(List<PoseLandmark> landmarks) {
    // ルールベースのスコア算出ロジック
    // ...
    return 85.0;
  }
}
```

#### 8.5.2 仮名化実装

**法的根拠**: プライバシーポリシーv3.1第8.3条、GDPR第4条5項

```typescript
import * as crypto from 'crypto';

/**
 * 仮名化サービス
 */
export class PseudonymizationService {
  private readonly salt: string;
  
  constructor() {
    this.salt = process.env.PSEUDONYMIZATION_SALT || 
                functions.config().pseudonymization.salt;
  }
  
  /**
   * ユーザーIDの仮名化
   * SHA-256ハッシュ化
   */
  pseudonymizeUserId(userId: string): string {
    return crypto
      .createHash('sha256')
      .update(userId + this.salt)
      .digest('hex');
  }
  
  /**
   * IPアドレスの仮名化
   * 最後のオクテットをマスク
   */
  pseudonymizeIpAddress(ipAddress: string): string {
    const parts = ipAddress.split('.');
    if (parts.length === 4) {
      // IPv4: 最後のオクテットを0に
      return `${parts[0]}.${parts[1]}.${parts[2]}.0`;
    }
    
    // IPv6の場合も同様にマスク
    const ipv6Parts = ipAddress.split(':');
    if (ipv6Parts.length > 0) {
      return ipv6Parts.slice(0, -1).join(':') + ':0';
    }
    
    return ipAddress;
  }
  
  /**
   * メールアドレスの仮名化
   * ハッシュ化
   */
  pseudonymizeEmail(email: string): string {
    return crypto
      .createHash('sha256')
      .update(email.toLowerCase() + this.salt)
      .digest('hex');
  }
}
```

---

## 9. データフロー

### 9.1 トレーニングセッションデータフロー

```
┌─────────────┐
│ ユーザー     │
└──────┬──────┘
       │ 1. カメラ起動
       ▼
┌─────────────────────────────────────────┐
│ Flutter App (端末上)                    │
│  ┌──────────────────────────────────┐  │
│  │ MediaPipe Pose                   │  │
│  │ - カメラ映像処理(オンデバイス)   │  │
│  │ - 骨格検出                       │  │
│  │ - 参考スコア算出                 │  │
│  └──────────────────────────────────┘  │
│         │ 2. 骨格座標のみ抽出         │
│         ▼ (カメラ映像は送信しない)     │
│  ┌──────────────────────────────────┐  │
│  │ Local Storage (Hive)             │  │
│  │ - セッションデータ一時保存       │  │
│  │ - AES-256暗号化                  │  │
│  └──────────────────────────────────┘  │
└─────────────┬───────────────────────────┘
              │ 3. TLS 1.3暗号化通信
              ▼
┌─────────────────────────────────────────┐
│ Firebase                                │
│  ┌──────────────────────────────────┐  │
│  │ Firestore                        │  │
│  │ - セッションデータ保存           │  │
│  │ - Security Rules適用             │  │
│  │ - 自動暗号化(AES-256)            │  │
│  └──────────────────────────────────┘  │
│         │ 4. Trigger                   │
│         ▼                               │
│  ┌──────────────────────────────────┐  │
│  │ Cloud Functions                  │  │
│  │ - ユーザーIDを仮名化             │  │
│  │ - BigQueryへエクスポート         │  │
│  └──────────────────────────────────┘  │
└─────────────┬───────────────────────────┘
              │ 5. 仮名化データ
              ▼
┌─────────────────────────────────────────┐
│ BigQuery                                │
│ - 仮名化されたデータ保存                │
│ - パーティショニング(日付)              │
│ - クラスタリング(ユーザーID、種目ID)    │
│ - 自動暗号化(AES-256)                   │
└─────────────────────────────────────────┘
```

**プライバシー保護ポイント**:
1. カメラ映像は端末上でのみ処理
2. 骨格座標のみをサーバーに送信
3. ユーザーIDは仮名化(SHA-256)
4. すべての通信をTLS 1.3で暗号化
5. すべての保存データをAES-256で暗号化

### 9.2 GDPR権利行使データフロー

#### 9.2.1 データエクスポート(FR-027)

```
┌─────────────┐
│ ユーザー     │
└──────┬──────┘
       │ 1. エクスポートリクエスト
       ▼
┌─────────────────────────────────────────┐
│ Flutter App                             │
│  - エクスポートボタンタップ             │
└─────────────┬───────────────────────────┘
              │ 2. HTTP Call (JWT認証)
              ▼
┌─────────────────────────────────────────┐
│ Cloud Functions: exportUserData         │
│  1. 認証確認                            │
│  2. Firestoreからデータ取得             │
│  3. BigQueryからデータ取得(仮名化ID)    │
│  4. JSON/CSV形式に変換                  │
│  5. Cloud Storageに保存                 │
│  6. 署名付きURL生成(有効期限7日)        │
└─────────────┬───────────────────────────┘
              │ 3. ダウンロードURL返却
              ▼
┌─────────────────────────────────────────┐
│ Flutter App                             │
│  - ダウンロードリンク表示               │
└─────────────┬───────────────────────────┘
              │ 4. ダウンロード
              ▼
┌─────────────────────────────────────────┐
│ Cloud Storage                           │
│  - 一時ファイル(7日後自動削除)          │
└─────────────────────────────────────────┘
```

**対応期限**: 30日以内(GDPR第12条3項)

#### 9.2.2 データ削除(FR-025)

```
┌─────────────┐
│ ユーザー     │
└──────┬──────┘
       │ 1. アカウント削除リクエスト
       ▼
┌─────────────────────────────────────────┐
│ Flutter App                             │
│  - 削除確認ダイアログ表示               │
│  - 30日間の猶予期間通知                 │
└─────────────┬───────────────────────────┘
              │ 2. 削除確認
              ▼
┌─────────────────────────────────────────┐
│ Firebase Authentication                 │
│  - ユーザー削除                         │
└─────────────┬───────────────────────────┘
              │ 3. Trigger: onUserDelete
              ▼
┌─────────────────────────────────────────┐
│ Cloud Functions                         │
│  1. Firestoreから全データ削除           │
│  2. BigQueryから全データ削除            │
│  3. Cloud Storageから全ファイル削除     │
│  4. 削除完了メール送信                  │
└─────────────────────────────────────────┘
```

**対応期限**: 30日以内(GDPR第12条3項)

---

## 10. スケーラビリティ設計

### 10.1 水平スケーリング戦略

#### 10.1.1 Firestore自動スケーリング

```
┌────────────────────────────────────────────────┐
│ Firestore                                      │
│  - 自動シャーディング                          │
│  - 読み取り/書き込みの自動分散                 │
│  - レプリケーション(複数リージョン)            │
│  - 最大1,000,000 QPS                           │
└────────────────────────────────────────────────┘
```

**最適化**:
- ホットスポット回避(ランダムID使用)
- 複合インデックスの適切な設計
- バッチ処理の活用

#### 10.1.2 Cloud Functions自動スケーリング

```yaml
# functions/index.ts
export const processSession = functions
  .runWith({
    memory: '256MB',
    timeoutSeconds: 60,
    maxInstances: 100,  # 最大インスタンス数
  })
  .firestore.document('sessions/{sessionId}')
  .onCreate(async (snap, context) => {
    // 処理
  });
```

**スケーリング設定**:
- 最大インスタンス数: 100(デフォルトは1,000)
- コールドスタート対策: 最小インスタンス数1(本番環境)
- タイムアウト: 60秒

### 10.2 パフォーマンス最適化

#### 10.2.1 フロントエンド最適化

| 手法 | 実装 | 効果 |
|-----|------|------|
| **遅延読み込み** | go_routerによるコード分割 | 初期起動時間-50% |
| **画像最適化** | WebP形式、圧縮 | データ転送量-60% |
| **キャッシュ** | Hiveによるローカルキャッシュ | API呼び出し-70% |
| **メモリ管理** | 適切なdispose() | メモリリーク防止 |

```dart
// 画像最適化例
class OptimizedImage extends StatelessWidget {
  final String imageUrl;
  
  @override
  Widget build(BuildContext context) {
    return CachedNetworkImage(
      imageUrl: imageUrl,
      placeholder: (context, url) => CircularProgressIndicator(),
      errorWidget: (context, url, error) => Icon(Icons.error),
      cacheManager: CacheManager(
        Config(
          'customCacheKey',
          stalePeriod: Duration(days: 7),
          maxNrOfCacheObjects: 100,
        ),
      ),
    );
  }
}
```

#### 10.2.2 バックエンド最適化

| 手法 | 実装 | 効果 |
|-----|------|------|
| **インデックス** | 複合インデックス | クエリ速度+90% |
| **バッチ処理** | Firestore batch write | 書き込み効率+80% |
| **CDN** | Firebase Hosting | レスポンス時間-70% |
| **クエリ最適化** | パーティショニング、クラスタリング | BigQueryコスト-60% |

```typescript
// バッチ処理例
async function batchUpdateSessions(sessions: Session[]) {
  const firestore = admin.firestore();
  const batch = firestore.batch();
  
  sessions.forEach((session) => {
    const ref = firestore.collection('sessions').doc(session.id);
    batch.update(ref, session);
  });
  
  // 一括コミット(最大500操作)
  await batch.commit();
}
```

### 10.3 キャパシティプランニング

#### 10.3.1 MVP期間(0-4ヶ月)

| 指標 | 想定値 | Firestore制限 | 余裕率 |
|-----|--------|--------------|--------|
| **ユーザー数** | 1,000人 | 実質無制限 | ✅ |
| **DAU** | 200人 | 実質無制限 | ✅ |
| **読み取り/日** | 30,000回 | 50,000回(無料枠) | 40% |
| **書き込み/日** | 10,000回 | 20,000回(無料枠) | 50% |
| **ストレージ** | 5GB | 10GB(無料枠) | 50% |

#### 10.3.2 Phase 3以降(4-12ヶ月)

| 指標 | 想定値 | 対策 |
|-----|--------|------|
| **ユーザー数** | 10,000人 | Firestoreスケーリング |
| **DAU** | 2,000人 | Cloud Functions最大インスタンス増加 |
| **読み取り/日** | 300,000回 | 有料プラン移行 |
| **書き込み/日** | 100,000回 | バッチ処理最適化 |
| **ストレージ** | 50GB | BigQueryパーティション削除 |

---

## 11. 監視・ログ

### 11.1 監視アーキテクチャ

```
┌─────────────────────────────────────────────────────────┐
│                    Application                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ Flutter  │  │ Firebase │  │ Cloud    │             │
│  │ App      │  │ Services │  │ Functions│             │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘             │
└───────┼─────────────┼─────────────┼───────────────────┘
        │             │             │
        │             ▼             ▼
        │      ┌──────────────────────────┐
        │      │ Cloud Logging            │
        │      │ - アプリケーションログ   │
        │      │ - エラーログ             │
        │      │ - セキュリティログ       │
        │      └────────┬─────────────────┘
        │               │
        ▼               ▼
┌──────────────┐  ┌──────────────┐
│ Firebase     │  │ Cloud        │
│ Crashlytics  │  │ Monitoring   │
│ - クラッシュ │  │ - メトリクス │
│ - ANR        │  │ - アラート   │
└──────────────┘  └──────┬───────┘
        │                 │
        └────────┬────────┘
                 ▼
        ┌──────────────────┐
        │ Alerting         │
        │ - Slack通知      │
        │ - Email通知      │
        └──────────────────┘
```

### 11.2 ログ管理

#### 11.2.1 ログレベル

| レベル | 用途 | 例 |
|-------|------|---|
| **ERROR** | エラー、例外 | 認証失敗、API呼び出しエラー |
| **WARN** | 警告、非推奨 | 古いAPIバージョン使用 |
| **INFO** | 重要なイベント | ユーザー登録、セッション作成 |
| **DEBUG** | デバッグ情報 | 関数の入出力(開発環境のみ) |

#### 11.2.2 ログフォーマット

```typescript
// 構造化ログ
functions.logger.info('User session created', {
  userId: pseudonymizeUserId(userId), // 仮名化
  sessionId: sessionId,
  exerciseId: exerciseId,
  duration: duration,
  timestamp: new Date().toISOString(),
});

// エラーログ
functions.logger.error('Failed to export data to BigQuery', {
  error: error.message,
  stack: error.stack,
  userId: pseudonymizeUserId(userId),
  sessionId: sessionId,
  timestamp: new Date().toISOString(),
});
```

**プライバシー保護**:
- ユーザーIDは仮名化
- 個人識別情報をログに含めない
- 保存期間: 30日間

### 11.3 メトリクス監視

#### 11.3.1 アプリケーションメトリクス

```dart
class MetricsService {
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;
  
  /// セッション開始
  Future<void> logSessionStart(String exerciseId) async {
    await _analytics.logEvent(
      name: 'session_start',
      parameters: {
        'exercise_id': exerciseId,
        'timestamp': DateTime.now().toIso8601String(),
      },
    );
  }
  
  /// セッション完了
  Future<void> logSessionComplete(
    String exerciseId,
    int repCount,
    int duration,
    double averageScore,
  ) async {
    await _analytics.logEvent(
      name: 'session_complete',
      parameters: {
        'exercise_id': exerciseId,
        'rep_count': repCount,
        'duration': duration,
        'average_score': averageScore,
        'timestamp': DateTime.now().toIso8601String(),
      },
    );
  }
}
```

#### 11.3.2 パフォーマンスメトリクス

```typescript
// Cloud Functions
export const monitorPerformance = functions.https.onRequest(async (req, res) => {
  const startTime = Date.now();
  
  try {
    // 処理
    await doSomething();
    
    // パフォーマンスログ
    const duration = Date.now() - startTime;
    functions.logger.info('Function performance', {
      function: 'monitorPerformance',
      duration: duration,
      status: 'success',
    });
    
    res.status(200).send('OK');
  } catch (error) {
    const duration = Date.now() - startTime;
    functions.logger.error('Function error', {
      function: 'monitorPerformance',
      duration: duration,
      status: 'error',
      error: error.message,
    });
    
    res.status(500).send('Internal Server Error');
  }
});
```

### 11.4 アラート設定

#### 11.4.1 アラートポリシー

| アラート名 | 条件 | 通知先 | 対応 |
|----------|------|--------|------|
| **高エラー率** | エラー率 > 5% (5分間) | Slack, Email | 即座に調査 |
| **レスポンス遅延** | P95 > 1秒 (10分間) | Slack | 最適化検討 |
| **クラッシュ率上昇** | クラッシュ率 > 1% | Slack, Email | 緊急修正 |
| **セキュリティ脆弱性** | Security Command Center検知 | Slack, Email | 即座に対応 |
| **データ侵害疑い** | 異常なアクセスパターン | Slack, Email, SMS | インシデント対応 |

#### 11.4.2 アラート実装

```typescript
import { Monitoring } from '@google-cloud/monitoring';

const monitoring = new Monitoring.MetricServiceClient();

async function createAlert() {
  const projectId = 'your-project-id';
  const projectPath = monitoring.projectPath(projectId);
  
  const alertPolicy = {
    displayName: 'High Error Rate',
    conditions: [
      {
        displayName: 'Error rate > 5%',
        conditionThreshold: {
          filter: 'metric.type="cloudfunctions.googleapis.com/function/execution_count" AND resource.type="cloud_function"',
          comparison: 'COMPARISON_GT',
          thresholdValue: 0.05,
          duration: { seconds: 300 },
        },
      },
    ],
    notificationChannels: [
      'projects/your-project-id/notificationChannels/slack-channel-id',
    ],
  };
  
  await monitoring.createAlertPolicy({
    name: projectPath,
    alertPolicy: alertPolicy,
  });
}
```

---

## 12. 災害復旧

### 12.1 バックアップ戦略

#### 12.1.1 Firestoreバックアップ

```bash
# 日次バックアップ(Cloud Scheduler + Cloud Functions)
gcloud firestore export gs://backup-bucket/firestore/$(date +%Y%m%d)
```

**設定**:
- 頻度: 日次(午前3時)
- 保存期間: 30日間
- ロケーション: asia-northeast1
- 暗号化: AES-256

#### 12.1.2 BigQueryバックアップ

```sql
-- スナップショット作成
CREATE SNAPSHOT TABLE `fitness_data.sessions_snapshot_20251121`
CLONE `fitness_data.sessions`;

-- 定期的なエクスポート
EXPORT DATA OPTIONS(
  uri='gs://backup-bucket/bigquery/sessions_*.json',
  format='JSON',
  overwrite=true
) AS
SELECT * FROM `fitness_data.sessions`
WHERE DATE(created_at) >= CURRENT_DATE() - 30;
```

**設定**:
- 頻度: 週次
- 保存期間: 90日間

### 12.2 災害復旧計画

#### 12.2.1 復旧目標

| 指標 | 目標 | 説明 |
|-----|------|------|
| **RTO** (Recovery Time Objective) | 24時間 | サービス復旧までの目標時間 |
| **RPO** (Recovery Point Objective) | 24時間 | データ損失許容時間 |

#### 12.2.2 復旧手順

**Firestore復旧**:

```bash
# 1. バックアップの確認
gsutil ls gs://backup-bucket/firestore/

# 2. 復旧実行
gcloud firestore import gs://backup-bucket/firestore/20251121

# 3. 検証
# Firestoreコンソールでデータ確認
```

**BigQuery復旧**:

```sql
-- スナップショットから復元
CREATE TABLE `fitness_data.sessions_restored`
CLONE `fitness_data.sessions_snapshot_20251121`;

-- データ検証
SELECT COUNT(*), MIN(created_at), MAX(created_at)
FROM `fitness_data.sessions_restored`;
```

---

## 13. 開発・デプロイメント

### 13.1 開発環境

#### 13.1.1 環境分離

| 環境 | 用途 | Firebase Project | GCP Project |
|-----|------|-----------------|-------------|
| **dev** | 開発 | fitness-app-dev | fitness-app-dev |
| **staging** | ステージング | fitness-app-staging | fitness-app-staging |
| **prod** | 本番 | fitness-app-prod | fitness-app-prod |

#### 13.1.2 環境変数管理

```bash
# .env.dev
FIREBASE_API_KEY=dev_api_key
FIREBASE_PROJECT_ID=fitness-app-dev
PSEUDONYMIZATION_SALT=dev_salt

# .env.prod
FIREBASE_API_KEY=prod_api_key
FIREBASE_PROJECT_ID=fitness-app-prod
PSEUDONYMIZATION_SALT=prod_salt
```

**セキュリティ**:
- `.env` ファイルは `.gitignore` に追加
- 本番環境の環境変数はFirebase/GCP Secret Managerで管理

### 13.2 CI/CD パイプライン

#### 13.2.1 GitHub Actions

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.x'
      
      - name: Install dependencies
        run: flutter pub get
      
      - name: Run tests
        run: flutter test --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
  
  build-android:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
      
      - name: Build APK
        run: flutter build apk --release
      
      - name: Upload to Google Play
        uses: r0adkll/upload-google-play@v1
        with:
          serviceAccountJsonPlainText: ${{ secrets.SERVICE_ACCOUNT_JSON }}
          packageName: com.example.fitnessapp
          releaseFiles: build/app/outputs/flutter-apk/app-release.apk
          track: internal
  
  build-ios:
    needs: test
    runs-on: macos-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
      
      - name: Build IPA
        run: flutter build ipa --release
      
      - name: Upload to App Store
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: build/ios/ipa/Runner.ipa
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_API_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}
```

### 13.3 デプロイメント戦略

#### 13.3.1 段階的ロールアウト

```
1. Internal Testing (Alpha)
   ├─ 社内テスター: 5-10人
   ├─ 期間: 1週間
   └─ 目的: 基本動作確認

2. Closed Beta
   ├─ 選定ユーザー: 50-100人
   ├─ 期間: 2週間
   └─ 目的: 実環境での検証

3. Open Beta
   ├─ 一般ユーザー: 制限なし
   ├─ 期間: 2週間
   └─ 目的: 大規模負荷テスト

4. Production Release
   ├─ 段階的ロールアウト: 10% → 50% → 100%
   ├─ 期間: 1週間
   └─ 目的: リスク最小化
```

---

## まとめ

### v3.1の主な成果

✅ **法的要件との完全な整合性**:
- 要件定義書v3.1の全機能・非機能要件に対応
- 利用規約v3.1、プライバシーポリシーv3.1と完全整合
- 薬機法、GDPR/EDPB Guidelines準拠

✅ **セキュリティ・プライバシー保護**:
- TLS 1.3、AES-256による暗号化
- オンデバイス処理(カメラ映像)
- 仮名化(SHA-256)
- 多層防御戦略

✅ **スケーラビリティ**:
- Firebase自動スケーリング
- BigQueryによる大規模データ分析
- 段階的な成長に対応

✅ **運用・監視**:
- Cloud Logging、Cloud Monitoring
- アラート設定
- 災害復旧計画

### 次のステップ

このシステムアーキテクチャ設計書v3.1に基づき、以下のドキュメントを作成します:

1. **Firestoreデータベース設計書 v3.1**
2. **BigQuery設計書 v3.1**
3. **API設計書(Firebase Functions) v3.1**
4. **画面遷移図 + ワイヤーフレーム v3.1**
5. **5種目のフォーム確認ロジック詳細 v3.1**

---

**完成したドキュメント(v3.1)**:
- ✅ 要件定義書 v3.1
- ✅ 利用規約 v3.1
- ✅ プライバシーポリシー v3.1
- ✅ システムアーキテクチャ設計書 v3.1 (本ドキュメント)

---

**Document Version**: v3.1 (Part 3/3)  
**Last Updated**: 2025年11月21日  
**Author**: Project Team  
**Approved by**: (承認待ち)

---

**以上**
